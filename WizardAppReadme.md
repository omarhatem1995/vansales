# SDK Wizard Generated App Overview

This app was generated by the SDK Wizard.  The following provides an overview of the generated code and a few suggestions on where to go to customize the app.

## Table of Contents

- [SDK Wizard Generated App Overview](#sdk-wizard-generated-app-overview)
  - [Table of Contents](#table-of-contents)
  - [SDK Version](#sdk-version)
  - [Adding Libraries](#adding-libraries)
  - [Network Requests](#network-requests)
  - [Proxy Classes](#proxy-classes)
  - [Service Class](#service-class)
  - [Onboarding Customizations](#onboarding-customizations)
  - [Add a Custom Menu](#add-a-custom-menu)
  - [Architecture Components](#architecture-components)
    - [Data Binding](#data-binding)
  - [Offline Support](#offline-support)
    - [Customization of Offline Data Set](#customization-of-offline-data-set)
    - [Server Assigned Key and Offline Usage](#server-assigned-key-and-offline-usage)
  - [Identification Property](#identification-property)
  - [Detail Screens](#detail-screens)
  - [Show a Custom Screen](#show-a-custom-screen)
  - [Push Notifications](#push-notifications)
  - [Configuration Loader](#configuration-loader)
  - [Troubleshooting](#troubleshooting)

## SDK Version

The SDK version used by the application is set in the gradle.properties (for Project) file.
```text
sdkVersion=7.1.0
```

## Adding Libraries

Additional SDK libraries such as the Offline OData library can be added by editing app's build.gradle (Module:app) file in the dependencies section as shown below.
```text
// SAP BTP SDK for Android dependencies
implementation group: 'com.sap.cloud.android', name: 'fiori', version: sdkVersion
implementation group: 'com.sap.cloud.android', name: 'onboarding', version: sdkVersion
implementation group:'com.sap.cloud.android', name:'odata', version: sdkVersion
implementation group: 'com.sap.cloud.android', name: 'foundation', version: sdkVersion
implementation group: 'com.sap.cloud.android', name: 'offline-odata', version: sdkVersion
```

## Network Requests

The app is designed to use a single OkHttpClient which is configured when the app is started. If you wish to make a network request (such as to set http handler for `OnlineODataProvider` to open odata store) to mobile services, you can access an instance of the OkHttpClient using the following code.

```kotlin
OKHttpHandler(ClientProvider.get())
```

## Proxy Classes

The Wizard-generated application leverages both service (`EntityContainer`) and proxy (`Entity`) classes generated by the OData gradle plugin to interact with the specified mobile application hosted in SAP Mobile Services. Code generated by the OData gradle plugin can be found under the `app/build/generated/source/odata` directory. The settings for the proxy generation are in the app's `build.gradle` file under an odata section.

Should the OData service change its metadata, corresponding classes will be regenerated on execution of relevant gradle tasks. It will impact the existing application if changes are not compatible. See documentation for what constitutes compatible changes. For online,`SAPServiceManager` is responsible for instantiating the generated service class, while for offline, `OfflineWorkerUtil` is responsible for that.

## Service Class

If you wish to make an OData query, you can access an instance of the service class using the below code. This example is from the service class generated against the sample back end.

```kotlin
//get the DataService class which we will use to query the Back-End OData service
val sapServiceManager = (application as SAPWizardApplication).sapServiceManager
val espmContainer = sapServiceManager?.eSPMContainer

val query = DataQuery()
        .filter(ProductCategory.numberOfProducts.greaterThan(0))
        .orderBy(ProductCategory.mainCategoryName)
        .orderBy(ProductCategory.categoryName)
espmContainer.executeQuery(query)
```

Above code is for online scenario, as for offline case, you can get the DataService class using the following code.

```kotlin
//get the DataService class initialized by OfflineWorkerUtil to query the Back-End OData service later
val espmContainer = OfflineWorkerUtil.eSPMContainer

val query = DataQuery().filter(ProductCategory.numberOfProducts.greaterThan(0))
      .orderBy(ProductCategory.mainCategoryName)
      .orderBy(ProductCategory.categoryName)

espmContainer.executeQuery(query)
```

## Onboarding Customizations

A few of the Welcome screen customizations include the title, app icon, description and privacy terms of service URL.
For additional details consult [Launch Screen Example](https://help.sap.com/doc/f53c64b93e5140918d676b927a3cd65b/Cloud/en-US/docs-en/guides/features/onboarding/android/fiori-screens/launch-screen.html#example).

## Add a Custom Menu

The following steps will add a custom menu to the `EntitySetListActivity`.

In `EntitySetListActivity.kt`, in the `onCreateOptionsMenu`, add the below line.

```kotlin
menu.add( Menu.NONE, 300, 1, "Custom Menu")
```

In the method, `onOptionsItemSelected`, add the following to handle the click of the menu.

```kotlin
300 -> {
    LOGGER.debug("Custom menu clicked.")
    true
}
```

## Architecture Components

This version utilize Android's new Architecture Components: ViewModel, Repository, DataBinding and LiveData. Each entity set will have its own set of activities, fragments, view model, XML layout and repository. When using the generated application as a starting point for development, unnecessary entity types can be purged by simply removing the corresponding files:

- res/layout (files): fragment\_<entity_set>\_detail.xml, fragment\_<entity_set>\_create.xml
- src/.../<package_name>/mdui (directory): \<entity-set\>
- src/.../<package_name>/view_model (directory): \<entity-set\>

In addition, update the following files to remove reference to the unwanted entity set

- src/.../<package_name>/viewmodel/EntityViewModelFactory.kt
- src/.../<package_name>/mdui/EntitySetListActivity.kt
- res/AndroidManifest.xml

### Data Binding

XML layout files for each entity set uses one and two-way databinding to an instance of the proxy class for viewing and editing. For Android UI components like EditText, TextView, etc., the necessary adapters are available from the corresponding Android library for data types. However, the use of Fiori UI components and additional OData data types require specific binding adapters. Please refer to the databinding directory under src for examples of one-way and two-way databindings of a proxy class to KeyValueCell (one-way) and SimplePropertyFormCell (two-way) Fiori UI components.

Note that the list of InverseMethods used for two-way databinding can be trimmed based on the actual set of data types that are required for the project. For example, GeometryPoint and related types can be removed if metadata document does not contain these data types.

## Offline Support

During offline application generation, a defining request, which queries the entire collection, will be generated for each entity set within the entity container. Thereafter, user can perform CRUD operations against local data offline. Local changes can be applied to the OData service when online through synchronization (upload followed by download). Local offline store is encrypted using an `encryptionKey` derived from the `SecureRandom().nextBytes(bytes)` method for single user mode or from the server via `UserSecureStoreDelegate` for multi-user mode. While this is a security best practice, in the event the offline store needs to be submitted for support purposes, the encryption key must be extracted via a debug session or change the application to skip encryption.

### Customization of Offline Data Set

Defining requests can be changed in `OfflineWorkerUtil.initializeOffline` method. By default, all data within each entity is downloaded. This is not normally done for a typical offline application as only a subset of the data is brought onto the device. For best practices of offline data definition, please refer to [Offline](https://help.sap.com/doc/f53c64b93e5140918d676b927a3cd65b/Cloud/en-US/docs-en/guides/features/offline/overview.html) section of SDK documentation.

### Server Assigned Key and Offline Usage

The generated application assumes that primary key(s) is assigned by the server. For online use case, the server key will be returned in the response of the operation. However, in offline use case, the key(s) is absent until an explicit synchronization is triggered through the main menu on the home screen. Since the key(s) is not even set, accessing them in two-way databinding during create/edit will cause an exception to be thrown. Hence, in create and update fragments, the key(s) is not visible. It is not advisable to initialize the key(s) due to the potential of duplicate key. While it is possible to generate random key values, it is not good for user experience as key value will change after synchronization. Hence, the compromise is to exclude them in create/edit screens.

Furthermore, one should always use read/editLink to access the new local instances.

## Identification Property

For each entity set, a random non-key property is selected to identify an instance of corresponding entity type. This property is also used to sort the returned collection. For an app generated against the SAP Sample Service Back End OData service, the City property for the Customers entity set is selected. To change to a different property, the followng three files for the Customers entity set are to be updated: (search for Customer.city and replaced with another property in the Customer entity set)
- CustomerViewModel.kt
- CustomersListFragment.kt
- CustomersDetailFragment.kt

Note: it is best to select a property that normally does not have null values. In some cases, perhaps the key property is appropriate.

## Detail Screens

The detail screen shows each property of the entity. The set of properties to be displayed can be changed by modifying the XML layout file: fragment_\<entity-set\>_detail.xml. For example, the Customers entity set will have the following layout files:
- fragment_customers_detail.xml (detail)
- fragment_customers_create.xml (create and update)

## Show a Custom Screen

The first screen shown following the onboarding screens is the `EntitySetListActivity` screen.  To instead show a different screen, modify `MainBusinessActivity.kt` and in the method `startEntitySetListActivity`, make the change below.

```kotlin
//val intent = Intent(this, EntitySetListActivity::class.java)
val intent = Intent(this, MyFirstActivity::class.java)
```

## Push Notifications

If the option Enable Push was checked on the Project Configuration page of the wizard, classes to enable the app to receive push notifications appear in the package `.notification`. You can select the Build Variants between `googlePlayStoreforGlobalMarket` and `tencentAppStoreforChinaMarket` to support `FCM` and `BaiduPush` respectively. One customization might be to change the title of the notification message if it is not included in the received message.  To do this, edit `PushCallbackListener` and in the `showMessageDialog` method modify the value of `notificationTitle`.

## Configuration Loader

The Configuration Loader is used to acquire general, non-secure configuration information, such as the Service URL from one of several sources. These sources include the Android Managed Configuration (previously known as application restrictions), an embedded resource file, or the Discovery Service. The sources are tried in the above order until a valid configuration is returned or no input is supplied for a provider, such as the Discovery Service that requires input. By default, the configuration data is persisted to `res/raw/sap_mobile_services.json`. Subsequently, the data is retrieved and accessed through the `FileConfigurationProvider`.

When a wizard generated application is initially started or reset, it needs to be onboarded. The onboarding process encompasses getting the configuration data and the initial authentication with the server. The onboarding process `startOnboarding` is handled by the `WelcomeActivity`, which invokes the `start` method of the `Flow` class. The `startOnboarding` method only will be executed when configuration data be loaded successfully. Upon success, `startOnboarding` performs the initial sever authentication, successfully exits the activity and onboarding is complete. Upon any failure, a dialog will be popped-up to provide hints.

The `startConfigurationLoader` private method simply instantiates a `ConfigurationLoader` object and calls `loadConfiguration` on it in a UI thread. The `loadConfiguration` method runs the loader in its own non-UI thread. The two threads communicate through messages passed through the `ConfigurationLoaderCallback` object methods and the `ConfigurationLoader.processRequestedInputs` method.

The `ConfigurationLoader` has several constructors. The one currently used employs the default queue and supplies the hard-coded Application ID to the discovery service provider. If desired, a developer can modify `startConfigurationLoader` and define their own configuration provider queue and pass it to the `ConfigurationLoader` constructor which takes a Context, the `ConfigurationLoaderCallback`, and a provider queue. The provider queue is simply an array of `ConfigurationProvider` objects in the order in which one wants them tried.


## Troubleshooting

While you are syncing the project, a `warning message` can appear in Android Studio.
"Could not find google-services.json while looking in [src/nullnull/debug, src/debug/nullnull, src/nullnull, src/debug, src/nullnullDebug]
registerResGeneratingTask is depricated, use registerGeneratedResFolders(FileCollection)"

You can ignore this warning message, it won't cause any problem.
